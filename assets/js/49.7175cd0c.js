(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{710:function(v,_,e){"use strict";e.r(_);var a=e(4),t=Object(a.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"什么是-web-缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-web-缓存"}},[v._v("#")]),v._v(" 什么是 Web 缓存")]),v._v(" "),e("p",[v._v("Web缓存（或HTTP缓存）是用于临时存储（缓存）Web文档（如HTML页面和图像），以减少服务器延迟的一种信息技术。Web缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。[1] Web缓存系统既可以指设备（英语：Server appliance），也可以指计算机程序。")]),v._v(" "),e("ul",[e("li",[v._v("HTTP 缓存分为两种："),e("code",[v._v("强制缓存")]),v._v("、"),e("code",[v._v("协商缓存")])])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[v._v("缓存主要是针对html,css,img等静态资源，常规情况下，我们不会去缓存一些动态资源，因为缓存动态资源的话，数据的实时性就不会不太好，所以我们一般都只会去缓存一些不太容易被改变的静态资源")])]),v._v(" "),e("h2",{attrs:{id:"优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[v._v("#")]),v._v(" 优缺点")]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[v._v("减少冗余的数据传输，节省了客户端流量")]),v._v(" "),e("li",[v._v("减少页面打开时间（因为已经缓存了相对应的资源文件）")]),v._v(" "),e("li",[v._v("减少服务器带宽压力")])]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[v._v("占内存（有些缓存会被存到内存中）")])]),v._v(" "),e("p",[v._v("流程图：")]),v._v(" "),e("p",[e("img",{attrs:{src:"/pageImg/220915/3.png",alt:""}})]),v._v(" "),e("h2",{attrs:{id:"控制缓存的基本机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#控制缓存的基本机制"}},[v._v("#")]),v._v(" 控制缓存的基本机制")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("新鲜度")]),v._v(" "),e("ul",[e("li",[v._v("允许在不在源服务器上重新检查的情况下使用一个响应，并且可以由服务器和客户端来控制。例如，Expires响应头给出文档过期的日期，而Cache-Control: max-age指示告诉缓存该响应在多少秒内保持新鲜。")])])]),v._v(" "),e("li",[e("p",[v._v("验证")]),v._v(" "),e("ul",[e("li",[v._v("可用于检查缓存的响应是否过时之后仍然有效。例如，若响应有一个Last-Modified头，缓存可以使用If-Modified-Since头来发出一个条件请求，来查看它是否已经改变。ETag（实体标签）机制还允许强弱验证。")])])]),v._v(" "),e("li",[e("p",[v._v("失效")]),v._v(" "),e("ul",[e("li",[v._v("通常是另一个请求通过缓存的一个结果。例如，如果与缓存的响应关联的URL随后获得POST、PUT或DELETE请求，则缓存的响应将失效。")])])])]),v._v(" "),e("h2",{attrs:{id:"web-缓存的流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web-缓存的流程"}},[v._v("#")]),v._v(" Web 缓存的流程")]),v._v(" "),e("ol",[e("li",[v._v("客户端发起请求 –> 无缓存 –> 连接服务器 –> 存缓存 –> 客户端得到数据")]),v._v(" "),e("li",[v._v("客户端发起请求 –> 有缓存 –> 够新鲜 –> 使用缓存 –> 客户端得到数据")]),v._v(" "),e("li",[v._v("客户端发起请求 –> 有缓存 –> 服务器验证是否过期 –> 没过期 –> 更新缓存的新鲜度 –> 客户端得到数据")]),v._v(" "),e("li",[v._v("客户端发起请求 –> 有缓存 –> 服务器验证是否过期 –> 已过期 –> 连接服务器 –> 存缓存 –> 客户端得到数据")])]),v._v(" "),e("h2",{attrs:{id:"强制缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[v._v("#")]),v._v(" 强制缓存")]),v._v(" "),e("h3",{attrs:{id:"expires-实现强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires-实现强缓存"}},[v._v("#")]),v._v(" Expires 实现强缓存")]),v._v(" "),e("p",[e("code",[v._v("Expires")]),v._v(" 作用设定一个强缓存时间。在此时间范围内，则从内存（或磁盘）中读取缓存返回")]),v._v(" "),e("ul",[e("li",[v._v("缺陷：过度依赖本地时间，在客户端与服务器时间不一致情况下会存在问题，所以现在基本是用 "),e("code",[v._v("Cache-control")])])]),v._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 设置方式")]),v._v("\nExpires: Wed, "),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("21")]),v._v(" Oct "),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("2015")]),v._v(" 07:28:00 GMT\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br")])]),e("h3",{attrs:{id:"cache-control-实现强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-实现强缓存"}},[v._v("#")]),v._v(" Cache-control 实现强缓存")]),v._v(" "),e("p",[v._v("请求头带上 "),e("code",[v._v("Cache-control")]),v._v("，并且定义相应属性。")]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("Cache-control")]),v._v(" 有 "),e("code",[v._v("max-age")]),v._v("、"),e("code",[v._v("s-maxage")]),v._v("、"),e("code",[v._v("no-cache")]),v._v("、"),e("code",[v._v("no-store")]),v._v("、"),e("code",[v._v("private")]),v._v("、"),e("code",[v._v("public")]),v._v(" 这六个属性")]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("max-age")]),v._v("：客户端资源缓存时长（单位秒）")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("s-maxage")]),v._v("：代理服务器缓存的时长（单位秒）")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("no-cache")]),v._v("：强制进行协商缓存")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("no-store")]),v._v("：禁止任何缓存策略")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("public")]),v._v("：资源可以被浏览器缓存也可以被代理服务器缓存")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("private")]),v._v("：资源只能被浏览器缓存")])])])])]),v._v(" "),e("ol",[e("li",[e("code",[v._v("max-age")]),v._v(" 与 "),e("code",[v._v("s-maxage")])])]),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("max-age")]),v._v(" 表示的时间资源在客户端缓存的时长，而"),e("code",[v._v("s-maxage")]),v._v("表示的是资源在代理服务器可以缓存的时长。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("s-maxage")]),v._v(" 是代理服务端的缓存时长，他必须和 "),e("code",[v._v("public")]),v._v(" 属性一起使用（public属性表示资源可以在代理服务器中缓存）。")])])]),v._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[v._v("Cache-Control:max-age"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[v._v("60")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 60就是需要缓存的秒数。从第一次请求资源的时候开始，往后60秒内，若再次请求资源，则直接从磁盘（或内存中读取），不与服务器做任何交互。")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# s-maxage 同理")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br")])]),e("ol",{attrs:{start:"2"}},[e("li",[e("code",[v._v("no-cache")]),v._v(" 与 "),e("code",[v._v("no-store")])])]),v._v(" "),e("p",[e("code",[v._v("no-cache")]),v._v(" 设置了该属性后，会直接跳过强缓存的校验，直接去服务器进行协商缓存")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[v._v("注："),e("code",[v._v("no-cache")]),v._v(" 和 "),e("code",[v._v("no-store")]),v._v(" 是一组互斥属性，这两个属性不能同时出现在 "),e("code",[v._v("Cache-Control")]),v._v(" 中")])]),v._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("code",[v._v("public")]),v._v(" 与 "),e("code",[v._v("private")])])]),v._v(" "),e("p",[v._v("这两个属性是用于，资源是否可以在代理服务器进行缓存的属性。")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("public")]),v._v(" 表示资源在客户端和代理服务器都可以被缓存")]),v._v(" "),e("li",[e("code",[v._v("private")]),v._v(" 表示资源只能在客户端被缓存，拒绝资源在代理服务器缓存")]),v._v(" "),e("li",[v._v("如果这两个属性值都没有被设置，则默认为"),e("code",[v._v("private")])])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[v._v("注："),e("code",[v._v("public")]),v._v(" 和 "),e("code",[v._v("private")]),v._v(" 是一组互斥属性，这两个属性不能同时出现在 "),e("code",[v._v("Cache-Control")]),v._v(" 中")])]),v._v(" "),e("ul",[e("li",[v._v("注： "),e("code",[v._v("Cache-control")]),v._v(" 设置多值，用逗号分隔")])]),v._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("Cache-control:max-age=60,s-maxage=60,public\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br")])]),e("h2",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),e("h3",{attrs:{id:"基于-last-modified-的协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于-last-modified-的协商缓存"}},[v._v("#")]),v._v(" 基于 last-modified 的协商缓存")]),v._v(" "),e("ol",[e("li",[v._v("首先需要在服务器端读出文件修改时间")]),v._v(" "),e("li",[v._v("将读出来的修改时间赋给响应头的"),e("code",[v._v("last-modified")]),v._v("字段")]),v._v(" "),e("li",[v._v("最后设置"),e("code",[v._v("Cache-control:no-cache")])])]),v._v(" "),e("ul",[e("li",[v._v("缺陷：依赖于文件更新时间，比如在请求过程中进行了文件更新，存在时间差问题")])]),v._v(" "),e("p",[e("img",{attrs:{src:"/pageImg/220915/2.png",alt:""}})]),v._v(" "),e("h3",{attrs:{id:"基础-etag-的协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础-etag-的协商缓存"}},[v._v("#")]),v._v(" 基础 ETag 的协商缓存")]),v._v(" "),e("p",[e("code",[v._v("ETag")]),v._v(" 比较文件指纹（根据文件内容计算出的唯一哈希值，文件内容一旦改变则指纹改变）")]),v._v(" "),e("p",[v._v("流程：")]),v._v(" "),e("ol",[e("li",[v._v("第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的 "),e("code",[v._v("ETag")]),v._v(" 字段中跟资源一起返回给客户端。")]),v._v(" "),e("li",[v._v("第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的 "),e("code",[v._v("ETag")]),v._v(" 也就是文件指纹。并赋给请求头的 "),e("code",[v._v("if-None-Match")]),v._v(" 字段，让上一次的文件指纹跟随请求一起回到服务端。")]),v._v(" "),e("li",[v._v("服务端拿到请求头中的 "),e("code",[v._v("is-None-Match")]),v._v(" 字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的 "),e("code",[v._v("ETag")]),v._v(" 中并返回给客户端")])]),v._v(" "),e("p",[e("img",{attrs:{src:"/pageImg/220915/1.png",alt:""}})]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("ETag")]),v._v(" 需要计算文件指纹这样意味着，服务端需要更多的计算开销。如果文件尺寸大，数量多，并且计算频繁，那么 "),e("code",[v._v("ETag")]),v._v(" 的计算就会影响服务器的性能。显然，"),e("code",[v._v("ETag")]),v._v(" 在这样的场景下就不是很适合。")]),v._v(" "),e("li",[e("code",[v._v("ETag")]),v._v(" 有强验证和弱验证，所谓将强验证，"),e("code",[v._v("ETag")]),v._v(" 生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。"),e("code",[v._v("ETag")]),v._v("还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",[v._v("值得注意的一点是，不同于"),e("code",[v._v("cache-control")]),v._v("是"),e("code",[v._v("expires")]),v._v("的完全替代方案(说人话:能用"),e("code",[v._v("cache-control")]),v._v("就不要用"),e("code",[v._v("expiress")]),v._v(")。"),e("code",[v._v("ETag")]),v._v("并不是"),e("code",[v._v("last-modified")]),v._v("的完全替代方案。而是"),e("code",[v._v("last-modified")]),v._v("的补充方案（说人话：项目中到底是用"),e("code",[v._v("ETag")]),v._v("还是"),e("code",[v._v("last-modified")]),v._v("完全取决于业务场景，这两个没有谁更好谁更坏）。")])]),v._v(" "),e("h2",{attrs:{id:"如何设置缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何设置缓存"}},[v._v("#")]),v._v(" 如何设置缓存")]),v._v(" "),e("p",[v._v("后端在服务器配置设置或代码内设置")]),v._v(" "),e("h2",{attrs:{id:"不同文件对应哪些缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不同文件对应哪些缓存"}},[v._v("#")]),v._v(" 不同文件对应哪些缓存")]),v._v(" "),e("p",[v._v("有哈希值的文件设置"),e("code",[v._v("强缓存")]),v._v("，没有哈希值的文件设置"),e("code",[v._v("协商缓存")]),v._v("（比如index.html）")]),v._v(" "),e("p",[v._v("为什么感觉哈希值去设置？")]),v._v(" "),e("p",[v._v("因为哈希值会在每次打包后进行变更，如 js、css 文件。更改了文件名的文件，就是一个新的文件。")]),v._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("http缓存可以减少宽带流量，加快响应速度。")])]),v._v(" "),e("li",[e("p",[v._v("关于强缓存，"),e("code",[v._v("cache-control")]),v._v(" 是 "),e("code",[v._v("Expires")]),v._v(" 的完全替代方案，在可以使用 "),e("code",[v._v("cache-control")]),v._v(" 的情况下不要使用 "),e("code",[v._v("expires")])])]),v._v(" "),e("li",[e("p",[v._v("关于协商缓存, "),e("code",[v._v("etag")]),v._v(" 并不是 "),e("code",[v._v("last-modified")]),v._v(" 的完全替代方案，而是补充方案，具体用哪一个，取决于业务场景。")])]),v._v(" "),e("li",[e("p",[v._v("有些缓存是从磁盘读取，有些缓存是从内存读取，有什么区别？答：从内存读取的缓存更快。")])]),v._v(" "),e("li",[e("p",[v._v("所有带304的资源都是协商缓存，所有标注（从内存中读取/从磁盘中读取）的资源都是强缓存。")])])]),v._v(" "),e("p",[v._v("参考："),e("a",{attrs:{href:"https://juejin.cn/post/7127194919235485733",target:"_blank",rel:"noopener noreferrer"}},[v._v("前端缓存"),e("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=t.exports}}]);